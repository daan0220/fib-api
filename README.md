# フィボナッチ数を返す API サービスの開発　

## What (このドキュメントはなにを示すのか)

1. ディレクトリ構成に関する説明

   - 目的や利点について説明
     - 拡張・修正に関して

2. フィボナッチ数列を返す処理の内容

   - CalculateFibonacci 関数のロジックの説明
     - 入力値 n に応じてフィボナッチ数列の計算を行う方法について

3. テストに関する説明

   - API ドキュメント実行コマンドの説明（swagger）

   - fibonacci_test.go および controller_test.go ファイルのテストケースに関して
     - それぞれのテストケースがどのような入力値と期待結果を持ち、どのようにテストが実行されるかが示している
     - テストの目的や使用されるアサーション関数についての説明

## Why 　（なぜこのようなディレクトリ構成にしたのか）

**ディレクトリ構成**

<pre>
.fibonacci
├── context
│   └── context.go
├── functions
│   └── calculate
│       ├── fibonacci_test.go
│       ├── fibonacci.go
├── inject
│   └── controller.go
├── presentation
│   ├── common
│   │   └── json.go
│   ├── controller_test.go
│   ├── controller.go
│   ├── response.go
├── root
│   └── router.go
├── go.mod
├── go.sum
├── main.go
├── swagger.yaml
└── zshrc

</pre>

**拡張・改修性（変更がしやすくて追加がしやすい）**

- なぜ拡張しやすいのか？

  - router.go にエンドポイントを記載しエンドポイントに対応するパスを presentation レイヤーのディレクトリで controller.go を作成して、そこにエンドポイントを対応するメソッドの関数を作成し inject でメソッドを作成するだけでエンドポイントを一個作れる

  - エンドポイントを作る作業に対して、決まったファイルに決まった書き方をするだけで一つのエンドポイントが作れる

- なぜ改修しやすいのか？

  - 責務や小さい粒度でファイル、フォルダを分けているためどこを修正するのかわかりやすい。

  - 共通で使用したい関数を切り出して共通化しているため、変更による影響範囲が多かったとしても修正量としては少なくなる

## How 　（指定したフィボナッチ数列を返す処理の概要）

- パフォーマンスの最適化

  - フィボナッチ数列は再帰的な定義を持つため、単純な再帰呼び出しでは効率的な計算が困難

  - 代わりに、ループ構造を使用してフィボナッチ数列を計算することで効率性を向上させる

  - ループによる計算では、再帰呼び出しに比べてメモリ使用量や処理時間の面で効率的

- BigInteger 演算の利用

  - フィボナッチ数列は指数的に増加するため、通常の整数型では数列の一部が範囲外になる可能性がある

  - math/big パッケージの big.Int 型を使用することで、BigInteger 演算をサポートし、数列の任意の桁数の計算が可能となる

  - big.Int 型は整数の計算においてオーバーフローの心配がなく、正確な結果を取得することができる

- 高精度計算のサポート

  - BigInteger 演算を利用することで、フィボナッチ数列の非常に大きな値も計算できる。また、整数の桁数に制限がなく、高い精度を持つ

  - 大規模な計算や高精度な数値処理が要求される場合にも対応できる

- 柔軟性と拡張性の向上

  - コードは単一の関数 CalculateFibonacci として抽象化されている

  - 他のコンポーネントやプログラムとの組み合わせが容易になる

  - 必要に応じて、関数を他のコードに組み込んだり、ライブラリとして使用したりできる

  - BigInteger 演算に関する操作やメソッドを活用することで、さらなる計算や操作の拡張が容易に行える

## How 　(テストに関して)

**API ドキュメント実装コマンド**

- $swagger serve swagger.yaml

**fibonacci_test.go**

- calculate.CalculateFibonacci 関数の機能検証

  - テストケースでは、異なる入力値 n を使用して関数を呼び出す

  - 関数の実行結果と期待される結果 expected を比較する

  - フィボナッチ数列の計算が正確かつ期待どおりに行われているかを確認できる

- 境界値のテスト

  - テストケースには境界値や特殊なケースが含まれている

  - n=0 や n=1 のようなフィボナッチ数列の最初の要素に対するテストがある

  - 関数が境界値や特殊なケースに対しても正しく動作するかを確認できる

**controller_test.go**

- fib.Get 関数（Fibonacci API のエンドポイント）の機能検証

  - テストケースでは、異なるパラメータや入力を用いて API を呼び出す

  - 期待されるステータスコードとレスポンスと実際の結果を比較する

  - API が要件を満たし、正しい結果と適切なエラーハンドリングを返すことを確認する

- エラーハンドリングのテスト

  - クエリパラメータが欠落している場合や不正な形式の場合など、エラーが発生するケースを含めることで、API が適切にエラーハンドリングを行うか確認する

- JSON のデシリアライズと比較

  - ステータスコードが http.StatusOK の場合、レスポンスボディを JSON としてデシリアライズし、期待されるレスポンスと比較する
  - これにより、API が正しい結果を返し、予期しない変更やデータ構造の問題がないことを確認する

**共通して言えること**

- 一貫性と再現性の確保

  - 同じテストケースを繰り返し実行することで、API や関数の出力が再現可能で一貫していることを検証する。その結果、API の実装が外部の状態に依存せず、安定した結果を返すことが期待されます。

- リファクタリングの安全性

  - テストケースがあることで、変更が予期しない副作用やバグを引き起こさないかを確認することができる。
  - 新しい実装や最適化を行っても、既存のテストが通過することを確認することが重要である。
